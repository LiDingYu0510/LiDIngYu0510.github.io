<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vue on Jamie Blog</title><link>http://example.org/categories/vue/</link><description>Recent content in Vue on Jamie Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 25 Mar 2022 12:00:00 +0000</lastBuildDate><atom:link href="http://example.org/categories/vue/index.xml" rel="self" type="application/rss+xml"/><item><title>[技術筆記]Vue中使用watch來監聽data變化</title><link>http://example.org/2022/03/255/vue_watch/</link><pubDate>Fri, 25 Mar 2022 12:00:00 +0000</pubDate><guid>http://example.org/2022/03/255/vue_watch/</guid><description>前言 目前我在手上的專案，要從 Vue2.6 轉換到 Vue3.0，剛好利用這個機會紀錄一下兩者的差別。
Vue2.x 的 watch 寫法 簡單寫法 假設欲觀察的值為 testData
data(){ return { testData:0 } }, watch:{ testData:(newValue, oldValue){ console.log(&amp;#34;data changed&amp;#34;) } } 完整寫法 假設欲觀察的值為 testData
data(){ return { testData:0 } }, watch:{ testData:{ immediate:true, //立即監聽（初次渲染時就執行） handler:(newValue, oldValue){ //監視的回調 console.log(newValue) } } } Vue3.0 的 watch 寫法 監視一個 ref 定義的響應式數據 假設欲觀察的值為 testData
setup(){ const testData = ref(0) watch(testData, (newValue, oldValue)=&amp;gt;{ console.log(&amp;#34;testData changed&amp;#34;, newValue) }) return {testData} } ps. immediate和deep的配置也可以使用；不過大多數情況 setup 中的 watch 都是 immediate 的</description></item><item><title>[技術筆記]Vue中的Event Bus</title><link>http://example.org/2022/03/24/vue_event_bus/</link><pubDate>Thu, 24 Mar 2022 12:00:00 +0000</pubDate><guid>http://example.org/2022/03/24/vue_event_bus/</guid><description>從 Vue2.x 到 Vue3 中的 EventBus 前言 在 Vue2 中，如果要實現跨組件的通訊，除了 Vuex之外，在小型專案也很常使用 event bus；但是在 Vue3 中，移除了 $on、$off、$emit等語法，沒辦法讓 event bus 使用其 api 來監聽。不過，Vue3 中可以用第三方 library mitt
Vue2.x 中的 Event Bus 第一種方法：在 main.js 中建立 event bus 屬性 main.js 中：
//在Vue實例中新增一個屬性 Vue.prototype.$eventBus = new Vue(); 在要監聽事件的組件中：
this.$on(&amp;#34;event name&amp;#34;,(*args)=&amp;gt;{ ... }) 在要觸發事件的組件中：
this.$emit(&amp;#34;event name&amp;#34;,*args) 第二種方法：直接建立新的 Vue 實例，當作 EventBus 在eventBus.js中
import Vue from &amp;#34;vue&amp;#34;; export const EventBus = new Vue(); 在要監聽事件的組件中：
import { EventBus } from &amp;#34;@/eventBus&amp;#34;; EventBus.</description></item><item><title>[技術筆記]在Vue自製plugin！</title><link>http://example.org/2022/03/17/vue_make_plugin/</link><pubDate>Thu, 17 Mar 2022 12:00:00 +0000</pubDate><guid>http://example.org/2022/03/17/vue_make_plugin/</guid><description>Vue 中自製 plugin 在 Vue2.x 中自製 plugin 添加全局方法 (pluginDemo.js)
export default { install(Vue) { Vue.myGlobalMethod = function (...args) { //...todo } } } 新增自訂指令（v-my-directive） (pluginDemo.js)
export default { install(Vue) { Vue.directive(&amp;#39;my-directive&amp;#39;, { bind (el, binding, vnode, oldVnode) { //... todo } }); } } 新增 mixin (pluginDemo.js)
export default{ install(Vue){ Vue.misin({ created:function(){ //...todo }, methods:{ demoFunc(){ //...todo } } }) } } 啟用組件 (pluginDemo.js)
export default { install(Vue) { Vue.component(&amp;#39;my-component&amp;#39;, MyComponent); } } 於 Vue 原型添加屬性 (pluginDemo.</description></item><item><title>[技術筆記]Vue3中，Typescript和Webpack5的路徑命名問題</title><link>http://example.org/2022/03/13/vue_typescript_webpack5/</link><pubDate>Sun, 13 Mar 2022 12:00:00 +0000</pubDate><guid>http://example.org/2022/03/13/vue_typescript_webpack5/</guid><description>Typescript 和 Webpack5 的路徑命名問題 前言 因為在專案中，原本只有在 webpack 中使用路徑重命名，發現在 vscode 中還是沒辦法找到該路徑，最後發現是 typescript 的編譯問題，因此來紀錄一下
Typescript 定義路徑別名： tsconfig.json 設定 { &amp;#34;compilerOptions&amp;#34;: { &amp;#34;paths&amp;#34;: { &amp;#34;@base/*&amp;#34;: [&amp;#34;src/*&amp;#34;], &amp;#34;@plugins/*&amp;#34;: [&amp;#34;src/plugins/*&amp;#34;], &amp;#34;@themes/*&amp;#34;: [&amp;#34;src/themes/*&amp;#34;], ...... } } } webpack5 的別名 webpack.config.js 設定 module.exports = { ... resolve:{ extensions: [&amp;#39;.ts&amp;#39;, &amp;#39;.js&amp;#39;, &amp;#39;.json&amp;#39;, &amp;#39;.css&amp;#39;, &amp;#39;.scss&amp;#39;, &amp;#39;.vue&amp;#39;], alias: { &amp;#39;@base&amp;#39;: path.resolve(__dirname, &amp;#39;src&amp;#39;), &amp;#39;@plugins&amp;#39;: path.resolve(__dirname, &amp;#39;src/plugins&amp;#39;), &amp;#39;@themes&amp;#39;: path.resolve(__dirname, &amp;#39;src/themes&amp;#39;), ... } }, ... } PS，如果在 webpack5 中的專案有使用 JWT 的 library 會報一個polyfill的錯</description></item></channel></rss>